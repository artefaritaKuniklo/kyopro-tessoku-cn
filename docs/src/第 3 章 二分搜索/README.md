# 二分法
## 什么是二分法
## 二分查找
## 二分答案
## 双指针

### 问题 A13 Close Pairs

N个整数写在黑板上。 所写的整数依次为：A1、A2、...、AN。 有 N(N-1)/2 对不同的整数。 一对不同的整数共有 N(N-1)/2 种选择方式，其中有多少种选择方式可以使差值小于或等于 K？ 有多少种方法可以选择一对整数，使其差值小于或等于 K？

输入格式
N K
A1 A2 ... AN

输出格式。
输出选择的棋子数量，使其差值小于或等于K。

数据范围
* 1 ≤ N ≤ 100000
* 1 ≤ K ≤ 10^9
* 1 ≤ a1 < a2 < ⋯ < an ≤ 10^9

输入示例 1 
7 10
11 12 16 22 27 28 31

输出示例 1
11

有11种方法来选择差值小于或等于10的整数对。

### 简单的解决方法
第一个可能的解决方案是暴力搜索。 计算所有配对的差额当然会得到正确的答案。
当然，正确的答案可以通过计算所有配对的差额来获得。 例如，如果 A=[11,12,16,22,27,28,31]，K=10，如下表所示。
然而，计算量是 O(N2)，速度较慢。

### 解决方案（1）：二分查找
那么，我们如何才能有效地计算出答案呢？ 首先，让 Ri 是满足 At≤Ai+K 的最大 t。
设 Ri 是满足 At≤Ai+K 的最大 t。 这个值对应于表格第 x 行中红色的列的数量。
该值对应于表格第 x 行中有多少列是红色的。 例如，R2 的值是 4。

对的数量是 (Ri-i)，这样 Ai 被选为较小的整数。 例如，有 4-2=2 种方法可以选择 A2=12 作为较小的整数。
选择 A2=12 作为小整数的方法是 4-2=2。 因此，这个问题的答案是
这个问题的答案可以表示为
(r1 - 1) + (r2 - 2) + ⋯ + (rn-1 - (n - 1))
因此，Ri的值可以通过数组的二进制搜索找到，计算复杂度为 O(log N)（→第3.1节）
然后，解决方案是对阵列进行分叉搜索（→第3.1节）。 使用这种解决方案，整个算法的计算复杂度为 O(N log N)。
当然，时间限制是可以达到的。

### 解决方案（2）：双指针法
然而，R1、R2、...、RN-1 值可以更有效地找到。 下面的算法被用来考虑计算Ri的值。
> **第1步** 如果 i = 1，从 Ri = 1 开始，否则从 Ri = Ri-1*1 开始
> **第2步** 差额 ARi - 重复将 Ri 增加 1 的操作，直到Ai勉强不超过K为止。
例如，在 A=[11,12,16,22,27,28,31] 和 K=10 的情况下，算法流程为
红色圆圈表示Ri的当前值。 红圈表示Ri的当前值。

从 R1 = 1 开始
A2 - 11 ≤ 10，所以增加 R1 = 2
A3 - 11 ≤ 10，所以增加 R1 = 3
A4 - 11 > 10，所以不能再增加。
从 R2 = 3 开始
A4 - 12 ≤ 10，所以增加 R2 = 4
A5 - 12 > 10，所以不能再增加。
从 R3 = 4 开始
A5 - 16 > 10，所以不能再增加。
从 R4 = 4 开始
A5 - 22 ≤ 10，所以增加 R4 = 5
A6 - 22 ≤ 10，所以增加到 R4 = 6
A7 - 22 ≤ 10，所以增加到 R4 = 7
从 R5 = 7 开始。
R5 是最后一个元素，所以
它不能再增加了。
从 R6 = 7 开始。
R6 是最后一个元素，所以
它不能再增加了。

在这种情况下，找到 R1、R2、...、RN-1 的所有值需要 O(N)。RN-1 找到所有的值需要 O(N) 的计算工作。 这是因为增加 Ri 的操作 总共只增加了 N-1 倍或更少。 因此，像例子中的解决方案的实施 因此，像解决方案例子中的实现可以产生正确的答案，其计算复杂度比二分法搜索快 O(N)。上面描述的算法因实现原理被称为双指针法，也被称为尺取法，因为算法流程与尺取虫的行走非常相似。

## 双向搜索
## 思考题