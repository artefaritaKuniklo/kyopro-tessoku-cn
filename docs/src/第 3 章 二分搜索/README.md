# 二分搜索
首先，让我们来尝试解决下面的问题，你会如何解决呢？

> 太郎想了 1 到 64 之间的一个整数。你可以提问至多 6 次，答案为 Yes/No 的问题，请猜出太郎所想的数字。

一个可能的策略是，「是 1 吗？」「是 2 吗？」「是 3 吗？」「是 4 吗？」一次一个进行询问。
若采用这样的策略，如果太郎所想的数字是 64，将会提问 64 次，就会输掉游戏。

但是，如果每次都以候选区间的中点作为分割进行询问，确实可以在 6 次以内达成。
首先考虑第一次询问，开始时的候补区间为 1 到 64 之间所有的整数，它的中点为 32，
因此提的问题是「小于等于 32 吗？」。

如果答案是 Yes，候选数字的的范围将缩小至 1 ～ 32，如果答案是 No，候选数字的的范围将缩小至 33 ～ 64。
无论哪种情况，候选数字的数量都从 64 人减少到一半变为 32 人。

接下来考虑第二次询问。如果第一个问题回答是 Yes，候选数字的范围就会缩小到 1 ～ 32，以现在对它的中点「小于等于 16 吗？」进行询问。
如果答案是 Yes，那么候选数字的范围就会缩小到 1 ～ 16；如果答案是 No，那么候选数字的范围就会缩小到 17 ～ 32。 
无论哪种情况，候选数字的数量都从 32 人减少到一半变为 16 人。

第三次后重复同样的问题，如下图所示，你将在 6 次尝试中获得正确答案。下面给出了当太郎所想的数为 23 时的示例图。
最后，他 6 次就猜中了，这只是一种运气吗？ 还是在 23 以外的情况下，都只需 6 次即可？答案是后者。因为采用这种策略，每次询问后，
候选数字的规模就减半了，64 → 32 → 16 → 8 → 4 → 2 → 1，以此类推。而当候选人的数量为 1 时，就可以确定答案。

这种通过在中间划分搜索区域而将问题规模每次减半的算法，被称为**二分搜索**。
在下一节中，我们将针对一个具体问题实现二分搜索。

## 什么是二分搜索

> A11 给定一个有 N 个元素的，严格递增的数组 A = [A1,A2,...,AN]，问数组中有多少元素 X 在阵列中的位置。
请注意，这个问题也可以通过简单的全搜索来解决（→第1.2节），但这里应该用二分搜索来实现。

## 数列的二分搜索
## 答案的二分搜索
## 双指针

### 问题 A13 Close Pairs

N个整数写在黑板上。 所写的整数依次为：A1、A2、...、AN。 有 N(N-1)/2 对不同的整数。 一对不同的整数共有 N(N-1)/2 种选择方式，其中有多少种选择方式可以使差值小于或等于 K？ 

输入格式
N K
A1 A2 ... AN

输出格式。
输出选择的棋子数量，使其差值小于或等于K。

数据范围
* 1 ≤ N ≤ 100000
* 1 ≤ K ≤ 10^9
* 1 ≤ a1 < a2 < ⋯ < an ≤ 10^9

输入示例 1 
7 10
11 12 16 22 27 28 31

输出示例 1
11

有11种方法来选择差值小于或等于10的整数对。

### 简单的解决方法
第一个可能的解决方案是暴力搜索。 计算所有配对的差额当然会得到正确的答案。
当然，正确的答案可以通过计算所有配对的差额来获得。 例如，如果 A=[11,12,16,22,27,28,31]，K=10，如下表所示。
然而，计算量是 O(N2)，速度较慢。

### 解决方案（1）：二分查找
那么，我们如何才能有效地计算出答案呢？ 首先，让 Ri 是满足 At≤Ai+K 的最大 t。
设 Ri 是满足 At≤Ai+K 的最大 t。 这个值对应于表格第 x 行中红色的列的数量。
该值对应于表格第 x 行中有多少列是红色的。 例如，R2 的值是 4。

对的数量是 (Ri-i)，这样 Ai 被选为较小的整数。 例如，有 4-2=2 种方法可以选择 A2=12 作为较小的整数。
选择 A2=12 作为小整数的方法是 4-2=2。 因此，这个问题的答案是
这个问题的答案可以表示为
(r1 - 1) + (r2 - 2) + ⋯ + (rn-1 - (n - 1))
因此，Ri的值可以通过数组的二进制搜索找到，计算复杂度为 O(log N)（→第3.1节）
然后，解决方案是对阵列进行分叉搜索（→第3.1节）。 使用这种解决方案，整个算法的计算复杂度为 O(N log N)。
当然，时间限制是可以达到的。

### 解决方案（2）：双指针法
然而，R1、R2、...、RN-1 值可以更有效地找到。 下面的算法被用来考虑计算Ri的值。
> **第1步** 如果 i = 1，从 Ri = 1 开始，否则从 Ri = Ri-1*1 开始
> **第2步** 差额 ARi - 重复将 Ri 增加 1 的操作，直到Ai勉强不超过K为止。
例如，在 A=[11,12,16,22,27,28,31] 和 K=10 的情况下，算法流程为
红色圆圈表示Ri的当前值。 红圈表示Ri的当前值。

从 R1 = 1 开始
A2 - 11 ≤ 10，所以增加 R1 = 2
A3 - 11 ≤ 10，所以增加 R1 = 3
A4 - 11 > 10，所以不能再增加。
从 R2 = 3 开始
A4 - 12 ≤ 10，所以增加 R2 = 4
A5 - 12 > 10，所以不能再增加。
从 R3 = 4 开始
A5 - 16 > 10，所以不能再增加。
从 R4 = 4 开始
A5 - 22 ≤ 10，所以增加 R4 = 5
A6 - 22 ≤ 10，所以增加到 R4 = 6
A7 - 22 ≤ 10，所以增加到 R4 = 7
从 R5 = 7 开始。
R5 是最后一个元素，所以
它不能再增加了。
从 R6 = 7 开始。
R6 是最后一个元素，所以
它不能再增加了。

在这种情况下，找到 R1、R2、...、RN-1 的所有值需要 O(N)。RN-1 找到所有的值需要 O(N) 的计算工作。 这是因为增加 Ri 的操作 总共只增加了 N-1 倍或更少。 因此，像例子中的解决方案的实施 因此，像解决方案例子中的实现可以产生正确的答案，其计算复杂度比二分法搜索快 O(N)。上面描述的算法因实现原理被称为双指针法，也被称为尺取法，因为算法流程与尺取虫的行走非常相似。

## 双向搜索
## 思考题